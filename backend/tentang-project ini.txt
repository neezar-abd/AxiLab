**PENJELASAN LENGKAP PROJECT AXI-LAB**

**KONSEP DASAR**

AXI-Lab adalah platform praktikum digital dengan 3 komponen utama:

1. Aplikasi Tablet untuk Siswa (pengumpulan data di lapangan)
2. Dashboard Web untuk Guru (monitoring dan penilaian)
3. Backend Server (otak sistem yang menghubungkan semua)

**ALUR KERJA LENGKAP STEP BY STEP**

**FASE 1: PERSIAPAN PRAKTIKUM (Guru)**

1. Guru buka browser, akses dashboard.axilab.com
2. Login dengan email dan password
3. Klik tombol "Buat Praktikum Baru"
4. Isi form:
   - Judul: "Identifikasi Tumbuhan Dikotil"
   - Mata Pelajaran: Biologi
   - Kelas: X IPA 1
   - Tanggal Pelaksanaan: 25 Oktober 2025
   - Durasi: 90 menit
5. Tentukan field data yang harus dikumpulkan siswa:
   - Field 1: Foto Daun (wajib, tipe: image)
   - Field 2: Foto Batang (wajib, tipe: image)
   - Field 3: Tinggi Tanaman (wajib, tipe: number, satuan: cm)
   - Field 4: Lokasi (wajib, tipe: text)
   - Field 5: Kondisi Daun (wajib, tipe: multiple choice: Segar/Layu/Kering)
6. Set kriteria penilaian:
   - Kelengkapan data: 30 poin
   - Kualitas foto: 30 poin
   - Keakuratan identifikasi: 40 poin
7. Tulis instruksi praktikum (markdown editor):
   ```
   Carilah 3 jenis tumbuhan dikotil di area sekolah.
   Foto setiap bagian dengan jelas.
   Ukur tinggi tanaman dengan meteran.
   ```
8. Klik "Simpan dan Publikasikan"
9. Sistem generate kode praktikum: PRAK-2025-001
10. Guru bagikan kode ini ke siswa

**YANG TERJADI DI BACKEND (Fase 1):**

```javascript
// API Endpoint: POST /api/practicum/create

Request dari Frontend Guru:
{
  "title": "Identifikasi Tumbuhan Dikotil",
  "subject": "Biologi",
  "class": "X IPA 1",
  "date": "2025-10-25",
  "duration": 90,
  "fields": [
    {
      "id": "field_1",
      "label": "Foto Daun",
      "type": "image",
      "required": true,
      "aiAnalysis": true
    },
    {
      "id": "field_2",
      "label": "Tinggi Tanaman",
      "type": "number",
      "unit": "cm",
      "required": true
    }
  ],
  "scoring": {
    "completeness": 30,
    "quality": 30,
    "accuracy": 40
  },
  "instructions": "Carilah 3 jenis tumbuhan..."
}

Backend Process:
1. Validasi data (semua field lengkap?)
2. Generate kode unik: PRAK-2025-001
3. Hash kode untuk keamanan
4. Simpan ke MongoDB collection "practicums"
5. Return response sukses ke frontend
```

**DATABASE SCHEMA (MongoDB):**

```javascript
// Collection: practicums
{
  "_id": ObjectId("..."),
  "code": "PRAK-2025-001",
  "codeHash": "a7b8c9d0...",
  "title": "Identifikasi Tumbuhan Dikotil",
  "subject": "Biologi",
  "class": "X IPA 1",
  "teacherId": ObjectId("..."),
  "date": ISODate("2025-10-25"),
  "duration": 90,
  "fields": [...],
  "scoring": {...},
  "instructions": "...",
  "status": "active", // active, completed, cancelled
  "createdAt": ISODate("..."),
  "updatedAt": ISODate("...")
}
```

**FASE 2: SISWA JOIN PRAKTIKUM**

1. Siswa buka aplikasi AXI-Lab di tablet
2. Login dengan NIS dan password
3. Tampil home screen dengan tombol "Join Praktikum"
4. Siswa input kode: PRAK-2025-001
5. Sistem verifikasi kode, tampilkan detail praktikum
6. Siswa klik "Mulai Praktikum"
7. Aplikasi download instruksi dan form field
8. Siswa bisa mulai mengumpulkan data

**YANG TERJADI DI BACKEND (Fase 2):**

```javascript
// API Endpoint: POST /api/practicum/join

Request:
{
  "studentId": "ObjectId(...)",
  "practicumCode": "PRAK-2025-001"
}

Backend Process:
1. Cek kode valid atau tidak di MongoDB
2. Cek siswa sudah join atau belum
3. Buat record baru di collection "submissions"
4. Return detail praktikum ke tablet
```

**DATABASE SCHEMA:**

```javascript
// Collection: submissions
{
  "_id": ObjectId("..."),
  "practicumId": ObjectId("..."),
  "studentId": ObjectId("..."),
  "studentName": "Budi Santoso",
  "studentClass": "X IPA 1",
  "status": "in_progress", // in_progress, submitted, graded
  "data": [], // akan diisi saat siswa upload
  "aiAnalysis": {}, // hasil analisis AI
  "teacherFeedback": "",
  "score": null,
  "startedAt": ISODate("..."),
  "submittedAt": null,
  "gradedAt": null
}
```

**FASE 3: PENGUMPULAN DATA (Siswa di Lapangan)**

**Skenario: Siswa menemukan tanaman pertama**

1. Siswa klik "Tambah Data Tanaman"
2. Aplikasi buka form dengan field yang sudah ditentukan guru
3. Siswa isi field satu per satu:

**Field 1: Foto Daun**
- Siswa klik tombol kamera
- Ambil foto daun
- Foto muncul di preview (resolusi asli 4000x3000, 4.2MB)

**PROSES DI APLIKASI TABLET:**

```javascript
// Frontend Tablet: Kompresi Foto

async function compressImage(file) {
  // Gunakan browser-image-compression library
  const options = {
    maxSizeMB: 1,
    maxWidthOrHeight: 1920,
    useWebWorker: true
  }
  
  const compressedFile = await imageCompression(file, options)
  // Hasil: 1920x1440, 800KB
  
  return compressedFile
}
```

**Field 2: Tinggi Tanaman**
- Siswa input: 45 (cm)

**Field 3: Lokasi**
- Siswa ketik: "Dekat kantin, sebelah kiri"

**Field 4: Kondisi Daun**
- Siswa pilih: Segar

4. Siswa klik "Simpan Data Tanaman"

**PROSES UPLOAD KE BACKEND:**

```javascript
// Frontend Tablet: Upload Data

async function submitPlantData() {
  // 1. Cek koneksi internet
  if (!navigator.onLine) {
    // Simpan ke IndexedDB (offline storage)
    await saveToIndexedDB(plantData)
    showNotification("Data disimpan offline, akan diupload otomatis")
    return
  }
  
  // 2. Siapkan FormData
  const formData = new FormData()
  formData.append('submissionId', currentSubmission._id)
  formData.append('plantNumber', 1)
  formData.append('photo_daun', compressedPhotoFile)
  formData.append('tinggi_tanaman', 45)
  formData.append('lokasi', 'Dekat kantin')
  formData.append('kondisi_daun', 'Segar')
  
  // 3. Upload dengan progress
  const response = await fetch('/api/submission/upload-data', {
    method: 'POST',
    body: formData,
    headers: {
      'Authorization': `Bearer ${userToken}`
    }
  })
  
  if (response.ok) {
    showNotification("Data berhasil diupload")
  }
}
```

**YANG TERJADI DI BACKEND:**

```javascript
// API Endpoint: POST /api/submission/upload-data

Backend Process (Synchronous):

1. Terima FormData dari tablet
2. Validasi:
   - Cek submissionId valid
   - Cek ukuran file < 5MB
   - Cek format file (jpg, png)
3. Generate unique filename: 
   "sub_123_plant1_daun_1729670400.jpg"
4. Upload foto ke MinIO bucket "axi-lab-photos"
5. Simpan metadata ke MongoDB:

{
  "submissionId": ObjectId("..."),
  "plantNumber": 1,
  "data": {
    "photo_daun": {
      "url": "https://minio.axilab.com/photos/sub_123_plant1_daun_1729670400.jpg",
      "filename": "sub_123_plant1_daun_1729670400.jpg",
      "size": 819200,
      "uploadedAt": ISODate("...")
    },
    "tinggi_tanaman": 45,
    "lokasi": "Dekat kantin",
    "kondisi_daun": "Segar"
  },
  "aiStatus": "pending" // pending, processing, completed, failed
}

6. Return response sukses ke tablet (cepat, 1-2 detik)

7. Tambahkan job ke Queue untuk AI analysis (asynchronous)
```

**PROSES AI ANALYSIS (Background Job):**

```javascript
// Backend: Bull Queue Worker

// File: queues/aiAnalysisQueue.js

import { Queue, Worker } from 'bullmq'
import Redis from 'ioredis'

const connection = new Redis({
  host: 'localhost',
  port: 6379
})

// Buat queue
export const aiQueue = new Queue('ai-analysis', { connection })

// Worker yang akan proses job
const worker = new Worker('ai-analysis', async (job) => {
  const { submissionId, plantNumber, photoUrl } = job.data
  
  console.log(`Processing AI analysis for submission ${submissionId}`)
  
  try {
    // 1. Download foto dari MinIO
    const photoBuffer = await downloadFromMinIO(photoUrl)
    
    // 2. Convert ke base64
    const base64Image = photoBuffer.toString('base64')
    
    // 3. Panggil Gemini API
    const prompt = `
      Kamu adalah ahli botani. Analisis foto daun ini dan berikan:
      1. Nama ilmiah tumbuhan (jika bisa diidentifikasi)
      2. Nama umum dalam bahasa Indonesia
      3. Ciri-ciri khas yang terlihat
      4. Apakah termasuk tumbuhan dikotil atau monokotil
      5. Tingkat kepercayaan identifikasi (0-100%)
      
      Format response dalam JSON:
      {
        "scientificName": "...",
        "commonName": "...",
        "characteristics": ["...", "..."],
        "type": "dikotil/monokotil",
        "confidence": 85
      }
    `
    
    const response = await fetch('https://generativelanguage.googleapis.com/v1/models/gemini-1.5-flash:generateContent', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'x-goog-api-key': process.env.GEMINI_API_KEY
      },
      body: JSON.stringify({
        contents: [{
          parts: [
            { text: prompt },
            {
              inline_data: {
                mime_type: "image/jpeg",
                data: base64Image
              }
            }
          ]
        }]
      })
    })
    
    const result = await response.json()
    const aiText = result.candidates[0].content.parts[0].text
    
    // 4. Parse JSON dari response AI
    const jsonMatch = aiText.match(/\{[\s\S]*\}/)
    const aiAnalysis = JSON.parse(jsonMatch[0])
    
    // 5. Simpan hasil ke MongoDB
    await db.collection('submissions').updateOne(
      { 
        _id: ObjectId(submissionId),
        "data.plantNumber": plantNumber
      },
      {
        $set: {
          "data.$.aiAnalysis": aiAnalysis,
          "data.$.aiStatus": "completed",
          "data.$.aiProcessedAt": new Date()
        }
      }
    )
    
    // 6. Kirim notifikasi real-time ke Dashboard Guru via Socket.io
    io.to(`practicum_${practicumId}`).emit('ai-analysis-complete', {
      submissionId,
      plantNumber,
      studentName: "Budi Santoso",
      analysis: aiAnalysis
    })
    
    console.log(`AI analysis completed for submission ${submissionId}`)
    
  } catch (error) {
    console.error('AI analysis failed:', error)
    
    // Update status ke failed
    await db.collection('submissions').updateOne(
      { 
        _id: ObjectId(submissionId),
        "data.plantNumber": plantNumber
      },
      {
        $set: {
          "data.$.aiStatus": "failed",
          "data.$.aiError": error.message
        }
      }
    )
    
    // Retry 3x jika gagal
    if (job.attemptsMade < 3) {
      throw error // Bull akan auto retry
    }
  }
  
}, { connection })

worker.on('completed', (job) => {
  console.log(`Job ${job.id} completed`)
})

worker.on('failed', (job, err) => {
  console.log(`Job ${job.id} failed:`, err.message)
})
```

**FASE 4: MONITORING REAL-TIME (Dashboard Guru)**

**Setup Socket.io Connection:**

```javascript
// Backend: Socket.io Setup

import { Server } from 'socket.io'
import jwt from 'jsonwebtoken'

export function setupSocketIO(httpServer) {
  const io = new Server(httpServer, {
    cors: {
      origin: process.env.FRONTEND_URL,
      credentials: true
    }
  })
  
  // Middleware autentikasi
  io.use((socket, next) => {
    const token = socket.handshake.auth.token
    
    try {
      const decoded = jwt.verify(token, process.env.JWT_SECRET)
      socket.userId = decoded.userId
      socket.userRole = decoded.role
      next()
    } catch (err) {
      next(new Error('Authentication error'))
    }
  })
  
  io.on('connection', (socket) => {
    console.log(`User ${socket.userId} connected`)
    
    // Guru join room praktikum
    socket.on('join-practicum', (practicumId) => {
      if (socket.userRole !== 'teacher') {
        return socket.emit('error', 'Unauthorized')
      }
      
      socket.join(`practicum_${practicumId}`)
      console.log(`Teacher joined practicum ${practicumId}`)
    })
    
    socket.on('disconnect', () => {
      console.log(`User ${socket.userId} disconnected`)
    })
  })
  
  return io
}
```

**Frontend Dashboard Guru:**

```javascript
// Frontend Guru: Real-time Dashboard

import { useEffect, useState } from 'react'
import { io } from 'socket.io-client'

export default function PracticumMonitor({ practicumId }) {
  const [submissions, setSubmissions] = useState([])
  const [socket, setSocket] = useState(null)
  
  useEffect(() => {
    // 1. Load data awal dari API
    fetchSubmissions()
    
    // 2. Setup Socket.io connection
    const socketInstance = io('https://api.axilab.com', {
      auth: {
        token: localStorage.getItem('token')
      }
    })
    
    setSocket(socketInstance)
    
    // 3. Join room praktikum
    socketInstance.emit('join-practicum', practicumId)
    
    // 4. Listen event real-time
    socketInstance.on('new-submission', (data) => {
      // Siswa baru join
      setSubmissions(prev => [...prev, data])
      showNotification(`${data.studentName} bergabung`)
    })
    
    socketInstance.on('data-uploaded', (data) => {
      // Siswa upload data baru
      setSubmissions(prev => prev.map(sub => 
        sub._id === data.submissionId 
          ? { ...sub, data: [...sub.data, data.newData] }
          : sub
      ))
      showNotification(`${data.studentName} upload data tanaman ${data.plantNumber}`)
    })
    
    socketInstance.on('ai-analysis-complete', (data) => {
      // AI selesai analisis
      setSubmissions(prev => prev.map(sub => 
        sub._id === data.submissionId
          ? {
              ...sub,
              data: sub.data.map(plant =>
                plant.plantNumber === data.plantNumber
                  ? { ...plant, aiAnalysis: data.analysis, aiStatus: 'completed' }
                  : plant
              )
            }
          : sub
      ))
      
      // Auto scroll ke submission yang baru dapat analisis
      scrollToSubmission(data.submissionId)
    })
    
    return () => socketInstance.disconnect()
  }, [practicumId])
  
  async function fetchSubmissions() {
    const response = await fetch(`/api/practicum/${practicumId}/submissions`, {
      headers: {
        'Authorization': `Bearer ${localStorage.getItem('token')}`
      }
    })
    const data = await response.json()
    setSubmissions(data.submissions)
  }
  
  return (
    <div className="grid grid-cols-3 gap-4">
      {submissions.map(sub => (
        <SubmissionCard 
          key={sub._id} 
          submission={sub}
          onGrade={handleGrade}
        />
      ))}
    </div>
  )
}
```

**Tampilan Dashboard Guru:**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Praktikum: Identifikasi Tumbuhan Dikotil           â”‚
â”‚ Kelas: X IPA 1 | Peserta: 35 siswa                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Budi Santoso â”‚ Ani Wijaya   â”‚ Candra Putra â”‚
â”‚ âœ… 3/3 data  â”‚ â³ 2/3 data  â”‚ â³ 1/3 data  â”‚
â”‚              â”‚              â”‚              â”‚
â”‚ Tanaman 1:   â”‚ Tanaman 1:   â”‚ Tanaman 1:   â”‚
â”‚ ğŸŒ¿ Foto âœ…   â”‚ ğŸŒ¿ Foto âœ…   â”‚ ğŸŒ¿ Foto âœ…   â”‚
â”‚ ğŸ¤– AI: âœ…    â”‚ ğŸ¤– AI: â³    â”‚ ğŸ¤– AI: â³    â”‚
â”‚ Mangga       â”‚ Processing.. â”‚ Processing.. â”‚
â”‚ (Conf: 92%)  â”‚              â”‚              â”‚
â”‚              â”‚              â”‚              â”‚
â”‚ Tanaman 2:   â”‚ Tanaman 2:   â”‚              â”‚
â”‚ ğŸŒ¿ Foto âœ…   â”‚ ğŸŒ¿ Foto âœ…   â”‚              â”‚
â”‚ ğŸ¤– AI: âœ…    â”‚ ğŸ¤– AI: âœ…    â”‚              â”‚
â”‚ Jambu        â”‚ Rambutan     â”‚              â”‚
â”‚              â”‚              â”‚              â”‚
â”‚ [Beri Nilai] â”‚ [Beri Nilai] â”‚ [Beri Nilai] â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**FASE 5: PENILAIAN (Guru)**

Guru klik card "Budi Santoso", modal muncul:

```javascript
// API Endpoint: POST /api/submission/grade

Request:
{
  "submissionId": "ObjectId(...)",
  "score": 85,
  "feedback": "Data lengkap dan foto jelas. Identifikasi tanaman 1 kurang tepat, seharusnya Mangifera indica bukan Mangifera foetida.",
  "breakdown": {
    "completeness": 30,
    "quality": 28,
    "accuracy": 27
  }
}

Backend Process:
1. Validasi guru berhak nilai submission ini
2. Update MongoDB:
   - Set score
   - Set feedback
   - Set status = "graded"
   - Set gradedAt = now
3. Kirim notifikasi ke tablet siswa via Socket.io
4. Return success
```

**FASE 6: GENERATE LAPORAN PDF**

Guru klik "Download Laporan Semua Siswa":

```javascript
// API Endpoint: POST /api/practicum/generate-reports

Backend Process:

1. Ambil semua submissions dari MongoDB
2. Loop setiap submission, generate PDF:

import puppeteer from 'puppeteer'

async function generatePDF(submission) {
  const browser = await puppeteer.launch({
    headless: true,
    args: ['--no-sandbox']
  })
  
  const page = await browser.newPage()
  
  // Render HTML template dengan data
  const html = `
    <!DOCTYPE html>
    <html>
    <head>
      <style>
        body { font-family: Arial; padding: 40px; }
        .header { text-align: center; margin-bottom: 30px; }
        .plant-data { margin-bottom: 20px; border: 1px solid #ccc; padding: 15px; }
        .photo { width: 300px; }
      </style>
    </head>
    <body>
      <div class="header">
        <h1>Laporan Praktikum</h1>
        <h2>${submission.practicumTitle}</h2>
        <p>Nama: ${submission.studentName}</p>
        <p>Kelas: ${submission.studentClass}</p>
        <p>Tanggal: ${formatDate(submission.submittedAt)}</p>
      </div>
      
      ${submission.data.map((plant, index) => `
        <div class="plant-data">
          <h3>Tanaman ${index + 1}</h3>
          <img src="${plant.photo_daun.url}" class="photo" />
          <p><strong>Tinggi:</strong> ${plant.tinggi_tanaman} cm</p>
          <p><strong>Lokasi:</strong> ${plant.lokasi}</p>
          <p><strong>Kondisi:</strong> ${plant.kondisi_daun}</p>
          
          <h4>Hasil Analisis AI:</h4>
          <p><strong>Nama Ilmiah:</strong> ${plant.aiAnalysis.scientificName}</p>
          <p><strong>Nama Umum:</strong> ${plant.aiAnalysis.commonName}</p>
          <p><strong>Tipe:</strong> ${plant.aiAnalysis.type}</p>
          <p><strong>Confidence:</strong> ${plant.aiAnalysis.confidence}%</p>
        </div>
      `).join('')}
      
      <div class="footer">
        <h3>Penilaian Guru</h3>
        <p><strong>Nilai:</strong> ${submission.score}/100</p>
        <p><strong>Feedback:</strong> ${submission.feedback}</p>
      </div>
    </body>
    </html>
  `
  
  await page.setContent(html, { waitUntil: 'networkidle0' })
  
  const pdfBuffer = await page.pdf({
    format: 'A4',
    printBackground: true,
    margin: { top: '20px', bottom: '20px' }
  })
  
  await browser.close()
  
  // Upload PDF ke MinIO
  const filename = `laporan_${submission._id}.pdf`
  await uploadToMinIO('axi-lab-reports', filename, pdfBuffer)
  
  return {
    filename,
    url: `https://minio.axilab.com/reports/${filename}`
  }
}

3. Zip semua PDF jadi satu file
4. Return download link ke guru
```

**SKENARIO OFFLINE (Detail Teknis)**

**Offline di Tablet Siswa:**

```javascript
// Service Worker + IndexedDB

// File: sw.js (Service Worker)

import { openDB } from 'idb'

const DB_NAME = 'axilab-offline'
const DB_VERSION = 1

async function initDB() {
  return await openDB(DB_NAME, DB_VERSION, {
    upgrade(db) {
      if (!db.objectStoreNames.contains('pending-uploads')) {
        db.createObjectStore('pending-uploads', { keyPath: 'id', autoIncrement: true })
      }
    }
  })
}

// Simpan data saat offline
async function saveOfflineData(data) {
  const db = await initDB()
  await db.add('pending-uploads', {
    ...data,
    timestamp: Date.now(),
    status: 'pending'
  })
}

// Sync saat online kembali
window.addEventListener('online', async () => {
  console.log('Back online, syncing data...')
  
  const db = await initDB()
  const pendingUploads = await db.getAll('pending-uploads')
  
  for (const upload of pendingUploads) {
    try {
      // Upload data ke backend
      const formData = new FormData()
      formData.append('submissionId', upload.submissionId)
      formData.append('photo_daun', upload.photoFile)
      formData.append('tinggi_tanaman', upload.tinggi)
      
      const response = await fetch('/api/submission/upload-data', {
        method: 'POST',
        body: formData
      })
      
      if (response.ok) {
        // Hapus dari IndexedDB jika sukses
        await db.delete('pending-uploads', upload.id)
        console.log(`Upload ${upload.id} synced successfully`)
      }
    } catch (error) {
      console.error(`Failed to sync upload ${upload.id}:`, error)
    }
  }
  
  showNotification('Semua data offline berhasil diupload')
})
```

**Offline di Dashboard Guru:**

```javascript
// Cache data dengan Service Worker

// File: sw-teacher.js

const CACHE_NAME = 'axilab-teacher-v1'
const urlsToCache = [
  '/',
  '/dashboard',
  '/styles/main.css',
  '/scripts/main.js'
]

self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open(CACHE_NAME)
      .then(cache => cache.addAll(urlsToCache))
  )
})

self.addEventListener('fetch', (event) => {
  event.respondWith(
    caches.match(event.request)
      .then(response => {
        // Return cached version jika ada
        if (response) {
          return response
        }
        
        // Jika tidak, fetch dari network
        return fetch(event.request).then(response => {
          // Cache response untuk request berikutnya
          if (event.request.url.includes('/api/')) {
            const responseClone = response.clone()
            caches.open(CACHE_NAME).then(cache => {
              cache.put(event.request, responseClone)
            })
          }
          return response
        })
      })
  )
})
```

**STRUKTUR FOLDER PROJECT**

```
axi-lab/
â”‚
â”œâ”€â”€ backend/
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ config/
â”‚   â”‚   â”‚   â”œâ”€â”€ database.js          # MongoDB connection
â”‚   â”‚   â”‚   â”œâ”€â”€ minio.js             # MinIO client setup
â”‚   â”‚   â”‚   â”œâ”€â”€ redis.js             # Redis connection untuk Bull
â”‚   â”‚   â”‚   â””â”€â”€ socket.js            # Socket.io setup
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ models/
â”‚   â”‚   â”‚   â”œâ”€â”€ User.js              # Model user (guru, siswa)
â”‚   â”‚   â”‚   â”œâ”€â”€ Practicum.js         # Model praktikum
â”‚   â”‚   â”‚   â””â”€â”€ Submission.js        # Model submission siswa
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ routes/
â”‚   â”‚   â”‚   â”œâ”€â”€ auth.routes.js       # Login, register
â”‚   â”‚   â”‚   â”œâ”€â”€ practicum.routes.js  # CRUD praktikum
â”‚   â”‚   â”‚   â”œâ”€â”€ submission.routes.js # Upload data, grading
â”‚   â”‚   â”‚   â””â”€â”€ report.routes.js     # Generate PDF
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ controllers/
â”‚   â”‚   â”‚   â”œâ”€â”€ authController.js
â”‚   â”‚   â”‚   â”œâ”€â”€ practicumController.js
â”‚   â”‚   â”‚   â”œâ”€â”€ submissionController.js
â”‚   â”‚   â”‚   â””â”€â”€ reportController.js
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â”‚   â”œâ”€â”€ geminiService.js     # Integrasi Gemini API
â”‚   â”‚   â”‚   â”œâ”€â”€ minioService.js      # Upload/download file
â”‚   â”‚   â”‚   â”œâ”€â”€ pdfService.js        # Generate PDF dengan Puppeteer
â”‚   â”‚   â”‚   â””â”€â”€ socketService.js     # Emit events ke frontend
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ queues/
â”‚   â”‚   â”‚   â”œâ”€â”€ aiAnalysisQueue.js   # Bull queue untuk AI
â”‚   â”‚   â”‚   â””â”€â”€ workers.js           # Worker process
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ middlewares/
â”‚   â”‚   â”‚   â”œâ”€â”€ auth.middleware.js   # JWT verification
â”‚   â”‚   â”‚   â”œâ”€â”€ upload.middleware.js # Multer file upload
â”‚   â”‚   â”‚   â””â”€â”€ error.middleware.js  # Error handling
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ utils/
â”‚   â”‚   â”‚   â”œâ”€â”€ imageCompression.js
â”‚   â”‚   â”‚   â”œâ”€â”€ validation.js
â”‚   â”‚   â”‚   â””â”€â”€ logger.js
â”‚   â”‚   â”‚
â”‚   â”‚   â””â”€â”€ server.js                # Entry point
â”‚   â”‚
â”‚   â”œâ”€â”€ package.json
â”‚   â””â”€â”€ .env
â”‚
â”œâ”€â”€ frontend-student/                # Next.js untuk tablet
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ app/
â”‚   â”‚```
â”‚   â”‚   â”œâ”€â”€ app/
â”‚   â”‚   â”‚   â”œâ”€â”€ layout.js
â”‚   â”‚   â”‚   â”œâ”€â”€ page.js              # Home/Login
â”‚   â”‚   â”‚   â”œâ”€â”€ dashboard/
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ page.js          # List praktikum yang diikuti
â”‚   â”‚   â”‚   â”œâ”€â”€ practicum/
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ [id]/
â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ page.js      # Detail praktikum & form input
â”‚   â”‚   â”‚   â”‚       â””â”€â”€ camera/
â”‚   â”‚   â”‚   â”‚           â””â”€â”€ page.js  # Interface kamera
â”‚   â”‚   â”‚   â””â”€â”€ history/
â”‚   â”‚   â”‚       â””â”€â”€ page.js          # Riwayat praktikum
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”‚   â”œâ”€â”€ CameraCapture.jsx    # Komponen ambil foto
â”‚   â”‚   â”‚   â”œâ”€â”€ FormField.jsx        # Dynamic form field
â”‚   â”‚   â”‚   â”œâ”€â”€ OfflineIndicator.jsx # Indikator status koneksi
â”‚   â”‚   â”‚   â”œâ”€â”€ UploadProgress.jsx   # Progress bar upload
â”‚   â”‚   â”‚   â””â”€â”€ DataCard.jsx         # Card untuk tampilan data
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ lib/
â”‚   â”‚   â”‚   â”œâ”€â”€ api.js               # Axios instance & API calls
â”‚   â”‚   â”‚   â”œâ”€â”€ indexedDB.js         # IndexedDB helper
â”‚   â”‚   â”‚   â”œâ”€â”€ imageCompression.js  # Kompresi foto
â”‚   â”‚   â”‚   â””â”€â”€ socket.js            # Socket.io client
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ hooks/
â”‚   â”‚   â”‚   â”œâ”€â”€ useOnlineStatus.js   # Hook detect online/offline
â”‚   â”‚   â”‚   â”œâ”€â”€ useCamera.js         # Hook untuk kamera
â”‚   â”‚   â”‚   â””â”€â”€ useSyncQueue.js      # Hook sync data offline
â”‚   â”‚   â”‚
â”‚   â”‚   â””â”€â”€ styles/
â”‚   â”‚       â””â”€â”€ globals.css
â”‚   â”‚
â”‚   â”œâ”€â”€ public/
â”‚   â”‚   â”œâ”€â”€ sw.js                    # Service Worker
â”‚   â”‚   â”œâ”€â”€ manifest.json            # PWA manifest
â”‚   â”‚   â””â”€â”€ icons/
â”‚   â”‚
â”‚   â”œâ”€â”€ next.config.js
â”‚   â”œâ”€â”€ package.json
â”‚   â””â”€â”€ .env.local
â”‚
â”œâ”€â”€ frontend-teacher/                # Next.js untuk dashboard guru
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ app/
â”‚   â”‚   â”‚   â”œâ”€â”€ layout.js
â”‚   â”‚   â”‚   â”œâ”€â”€ page.js              # Home/Login guru
â”‚   â”‚   â”‚   â”œâ”€â”€ dashboard/
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ page.js          # List praktikum guru
â”‚   â”‚   â”‚   â”œâ”€â”€ practicum/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ create/
â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ page.js      # Form buat praktikum
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ [id]/
â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ page.js      # Detail & monitoring
â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ edit/
â”‚   â”‚   â”‚   â”‚       â”‚   â””â”€â”€ page.js  # Edit praktikum
â”‚   â”‚   â”‚   â”‚       â””â”€â”€ reports/
â”‚   â”‚   â”‚   â”‚           â””â”€â”€ page.js  # Generate laporan
â”‚   â”‚   â”‚   â””â”€â”€ students/
â”‚   â”‚   â”‚       â””â”€â”€ page.js          # Manajemen data siswa
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”‚   â”œâ”€â”€ PracticumForm.jsx    # Form buat/edit praktikum
â”‚   â”‚   â”‚   â”œâ”€â”€ SubmissionCard.jsx   # Card submission siswa
â”‚   â”‚   â”‚   â”œâ”€â”€ GradingModal.jsx     # Modal penilaian
â”‚   â”‚   â”‚   â”œâ”€â”€ AIAnalysisView.jsx   # Tampilan hasil AI
â”‚   â”‚   â”‚   â”œâ”€â”€ RealtimeMonitor.jsx  # Real-time dashboard
â”‚   â”‚   â”‚   â””â”€â”€ StudentList.jsx      # List siswa
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ lib/
â”‚   â”‚   â”‚   â”œâ”€â”€ api.js
â”‚   â”‚   â”‚   â”œâ”€â”€ socket.js
â”‚   â”‚   â”‚   â””â”€â”€ exportPDF.js         # Helper download PDF
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ hooks/
â”‚   â”‚   â”‚   â”œâ”€â”€ usePracticum.js      # Hook untuk data praktikum
â”‚   â”‚   â”‚   â”œâ”€â”€ useSubmissions.js    # Hook untuk submissions
â”‚   â”‚   â”‚   â””â”€â”€ useRealtime.js       # Hook Socket.io events
â”‚   â”‚   â”‚
â”‚   â”‚   â””â”€â”€ styles/
â”‚   â”‚       â””â”€â”€ globals.css
â”‚   â”‚
â”‚   â”œâ”€â”€ next.config.js
â”‚   â”œâ”€â”€ package.json
â”‚   â””â”€â”€ .env.local
â”‚
â”œâ”€â”€ docker-compose.yml               # Container MongoDB, MinIO, Redis
â”œâ”€â”€ .gitignore
â””â”€â”€ README.md
```

**FILE KONFIGURASI PENTING**

**1. docker-compose.yml**

```yaml
version: '3.8'

services:
  mongodb:
    image: mongo:7.0
    container_name: axilab-mongodb
    restart: always
    ports:
      - "27017:27017"
    environment:
      MONGO_INITDB_ROOT_USERNAME: admin
      MONGO_INITDB_ROOT_PASSWORD: axilab2025
      MONGO_INITDB_DATABASE: axilab
    volumes:
      - mongodb_data:/data/db
    networks:
      - axilab-network

  redis:
    image: redis:7-alpine
    container_name: axilab-redis
    restart: always
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    networks:
      - axilab-network

  minio:
    image: minio/minio:latest
    container_name: axilab-minio
    restart: always
    ports:
      - "9000:9000"      # API port
      - "9001:9001"      # Console UI
    environment:
      MINIO_ROOT_USER: axilab
      MINIO_ROOT_PASSWORD: axilab2025
    command: server /data --console-address ":9001"
    volumes:
      - minio_data:/data
    networks:
      - axilab-network

volumes:
  mongodb_data:
  redis_data:
  minio_data:

networks:
  axilab-network:
    driver: bridge
```

**2. backend/.env**

```env
# Server
NODE_ENV=production
PORT=5000
API_URL=https://api.axilab.com

# Database
MONGODB_URI=mongodb://admin:axilab2025@localhost:27017/axilab?authSource=admin

# Redis
REDIS_HOST=localhost
REDIS_PORT=6379

# MinIO
MINIO_ENDPOINT=localhost
MINIO_PORT=9000
MINIO_ACCESS_KEY=axilab
MINIO_SECRET_KEY=axilab2025
MINIO_USE_SSL=false
MINIO_BUCKET_PHOTOS=axi-lab-photos
MINIO_BUCKET_VIDEOS=axi-lab-videos
MINIO_BUCKET_REPORTS=axi-lab-reports

# JWT
JWT_SECRET=axilab_secret_key_2025_very_secure_random_string
JWT_EXPIRES_IN=7d

# Gemini AI
GEMINI_API_KEY=AIzaSyxxxxxxxxxxxxxxxxxxxxxxxxxx

# Upload Limits
MAX_FILE_SIZE_MB=50
MAX_PHOTO_SIZE_MB=5
MAX_VIDEO_SIZE_MB=50

# Frontend URLs (untuk CORS)
FRONTEND_STUDENT_URL=https://student.axilab.com
FRONTEND_TEACHER_URL=https://teacher.axilab.com
```

**3. backend/package.json**

```json
{
  "name": "axilab-backend",
  "version": "1.0.0",
  "type": "module",
  "scripts": {
    "dev": "nodemon src/server.js",
    "start": "node src/server.js",
    "worker": "node src/queues/workers.js"
  },
  "dependencies": {
    "express": "^4.18.2",
    "mongoose": "^8.0.0",
    "socket.io": "^4.6.1",
    "bullmq": "^5.0.0",
    "ioredis": "^5.3.2",
    "minio": "^7.1.3",
    "puppeteer": "^21.6.1",
    "jsonwebtoken": "^9.0.2",
    "bcryptjs": "^2.4.3",
    "multer": "^1.4.5-lts.1",
    "sharp": "^0.33.0",
    "cors": "^2.8.5",
    "dotenv": "^16.3.1",
    "joi": "^17.11.0",
    "axios": "^1.6.2",
    "archiver": "^6.0.1"
  },
  "devDependencies": {
    "nodemon": "^3.0.2"
  }
}
```

**DETAIL API ENDPOINTS**

**Authentication APIs:**

```javascript
POST /api/auth/register
Body: {
  "name": "Budi Santoso",
  "email": "budi@student.com",
  "password": "password123",
  "role": "student", // student | teacher
  "studentId": "2024001", // khusus student
  "class": "X IPA 1"      // khusus student
}
Response: {
  "success": true,
  "token": "eyJhbGc...",
  "user": { "id": "...", "name": "...", "role": "..." }
}

POST /api/auth/login
Body: {
  "email": "budi@student.com",
  "password": "password123"
}
Response: {
  "success": true,
  "token": "eyJhbGc...",
  "user": { ... }
}

GET /api/auth/me
Headers: { "Authorization": "Bearer eyJhbGc..." }
Response: {
  "success": true,
  "user": { ... }
}
```

**Practicum APIs (Teacher):**

```javascript
POST /api/practicum/create
Headers: { "Authorization": "Bearer ..." }
Body: {
  "title": "Identifikasi Tumbuhan Dikotil",
  "subject": "Biologi",
  "class": "X IPA 1",
  "date": "2025-10-25T07:00:00Z",
  "duration": 90,
  "fields": [
    {
      "id": "field_1",
      "label": "Foto Daun",
      "type": "image",
      "required": true,
      "aiAnalysis": true,
      "aiPrompt": "Identifikasi spesies tumbuhan dari foto daun"
    },
    {
      "id": "field_2",
      "label": "Tinggi Tanaman",
      "type": "number",
      "unit": "cm",
      "required": true,
      "min": 0,
      "max": 1000
    },
    {
      "id": "field_3",
      "label": "Kondisi Daun",
      "type": "select",
      "required": true,
      "options": ["Segar", "Layu", "Kering"]
    }
  ],
  "instructions": "Carilah 3 jenis tumbuhan...",
  "minDataPoints": 3,
  "maxDataPoints": 5,
  "scoring": {
    "completeness": 30,
    "quality": 30,
    "accuracy": 40
  }
}
Response: {
  "success": true,
  "practicum": {
    "_id": "...",
    "code": "PRAK-2025-001",
    ...
  }
}

GET /api/practicum/list
Headers: { "Authorization": "Bearer ..." }
Query: ?status=active&page=1&limit=10
Response: {
  "success": true,
  "practicums": [...],
  "total": 15,
  "page": 1,
  "pages": 2
}

GET /api/practicum/:id
Headers: { "Authorization": "Bearer ..." }
Response: {
  "success": true,
  "practicum": { ... }
}

PUT /api/practicum/:id
Headers: { "Authorization": "Bearer ..." }
Body: { "title": "...", ... }
Response: {
  "success": true,
  "practicum": { ... }
}

DELETE /api/practicum/:id
Headers: { "Authorization": "Bearer ..." }
Response: {
  "success": true,
  "message": "Practicum deleted"
}

GET /api/practicum/:id/submissions
Headers: { "Authorization": "Bearer ..." }
Response: {
  "success": true,
  "submissions": [
    {
      "_id": "...",
      "studentId": "...",
      "studentName": "Budi Santoso",
      "status": "submitted",
      "data": [...],
      "score": 85,
      "submittedAt": "..."
    }
  ]
}
```

**Practicum APIs (Student):**

```javascript
POST /api/practicum/join
Headers: { "Authorization": "Bearer ..." }
Body: {
  "code": "PRAK-2025-001"
}
Response: {
  "success": true,
  "practicum": { ... },
  "submission": {
    "_id": "...",
    "status": "in_progress",
    "data": []
  }
}

GET /api/practicum/my-practicums
Headers: { "Authorization": "Bearer ..." }
Response: {
  "success": true,
  "practicums": [
    {
      "practicum": { ... },
      "submission": { ... }
    }
  ]
}
```

**Submission APIs:**

```javascript
POST /api/submission/upload-data
Headers: { 
  "Authorization": "Bearer ...",
  "Content-Type": "multipart/form-data"
}
Body (FormData): {
  "submissionId": "...",
  "dataPointNumber": 1,
  "field_1": <File>, // foto
  "field_2": 45,     // angka
  "field_3": "Segar" // text/select
}
Response: {
  "success": true,
  "dataPoint": {
    "number": 1,
    "data": {
      "field_1": {
        "url": "https://minio.../photo.jpg",
        "filename": "...",
        "size": 819200
      },
      "field_2": 45,
      "field_3": "Segar"
    },
    "aiStatus": "pending",
    "uploadedAt": "..."
  }
}

GET /api/submission/:id
Headers: { "Authorization": "Bearer ..." }
Response: {
  "success": true,
  "submission": {
    "_id": "...",
    "practicumId": "...",
    "studentId": "...",
    "status": "in_progress",
    "data": [
      {
        "number": 1,
        "data": { ... },
        "aiAnalysis": { ... },
        "aiStatus": "completed"
      }
    ]
  }
}

PUT /api/submission/:id/data/:dataNumber
Headers: { "Authorization": "Bearer ..." }
Body (FormData): { ... }
Response: {
  "success": true,
  "dataPoint": { ... }
}

DELETE /api/submission/:id/data/:dataNumber
Headers: { "Authorization": "Bearer ..." }
Response: {
  "success": true,
  "message": "Data point deleted"
}

POST /api/submission/:id/submit
Headers: { "Authorization": "Bearer ..." }
Response: {
  "success": true,
  "submission": {
    "status": "submitted",
    "submittedAt": "..."
  }
}

POST /api/submission/:id/grade
Headers: { "Authorization": "Bearer ..." }
Body: {
  "score": 85,
  "feedback": "Data lengkap dan foto jelas...",
  "breakdown": {
    "completeness": 30,
    "quality": 28,
    "accuracy": 27
  }
}
Response: {
  "success": true,
  "submission": {
    "status": "graded",
    "score": 85,
    "gradedAt": "..."
  }
}
```

**Report APIs:**

```javascript
POST /api/report/generate/:submissionId
Headers: { "Authorization": "Bearer ..." }
Response: {
  "success": true,
  "report": {
    "url": "https://minio.../reports/laporan_....pdf",
    "filename": "laporan_budi_santoso.pdf"
  }
}

POST /api/report/generate-bulk/:practicumId
Headers: { "Authorization": "Bearer ..." }
Response: {
  "success": true,
  "archive": {
    "url": "https://minio.../reports/laporan_praktikum_001.zip",
    "filename": "laporan_praktikum_001.zip",
    "totalReports": 35
  }
}
```

**DETAIL IMPLEMENTASI BACKEND**

**1. backend/src/server.js**

```javascript
import express from 'express'
import cors from 'cors'
import { createServer } from 'http'
import dotenv from 'dotenv'
import connectDB from './config/database.js'
import { setupSocketIO } from './config/socket.js'
import errorMiddleware from './middlewares/error.middleware.js'

// Routes
import authRoutes from './routes/auth.routes.js'
import practicumRoutes from './routes/practicum.routes.js'
import submissionRoutes from './routes/submission.routes.js'
import reportRoutes from './routes/report.routes.js'

dotenv.config()

const app = express()
const httpServer = createServer(app)

// Middleware
app.use(cors({
  origin: [
    process.env.FRONTEND_STUDENT_URL,
    process.env.FRONTEND_TEACHER_URL
  ],
  credentials: true
}))
app.use(express.json())
app.use(express.urlencoded({ extended: true }))

// Routes
app.use('/api/auth', authRoutes)
app.use('/api/practicum', practicumRoutes)
app.use('/api/submission', submissionRoutes)
app.use('/api/report', reportRoutes)

// Health check
app.get('/health', (req, res) => {
  res.json({ status: 'OK', timestamp: new Date() })
})

// Error handling
app.use(errorMiddleware)

// Connect database
await connectDB()

// Setup Socket.io
const io = setupSocketIO(httpServer)
app.set('io', io)

// Start server
const PORT = process.env.PORT || 5000
httpServer.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`)
  console.log(`Environment: ${process.env.NODE_ENV}`)
})

// Graceful shutdown
process.on('SIGTERM', () => {
  console.log('SIGTERM received, shutting down gracefully')
  httpServer.close(() => {
    console.log('Server closed')
    process.exit(0)
  })
})
```

**2. backend/src/config/database.js**

```javascript
import mongoose from 'mongoose'

async function connectDB() {
  try {
    await mongoose.connect(process.env.MONGODB_URI, {
      useNewUrlParser: true,
      useUnifiedTopology: true,
      maxPoolSize: 10,
      serverSelectionTimeoutMS: 5000,
      socketTimeoutMS: 45000
    })
    
    console.log('MongoDB connected successfully')
    
    // Event listeners
    mongoose.connection.on('error', (err) => {
      console.error('MongoDB connection error:', err)
    })
    
    mongoose.connection.on('disconnected', () => {
      console.warn('MongoDB disconnected')
    })
    
  } catch (error) {
    console.error('MongoDB connection failed:', error)
    process.exit(1)
  }
}

export default connectDB
```

**3. backend/src/config/minio.js**

```javascript
import * as Minio from 'minio'

const minioClient = new Minio.Client({
  endPoint: process.env.MINIO_ENDPOINT,
  port: parseInt(process.env.MINIO_PORT),
  useSSL: process.env.MINIO_USE_SSL === 'true',
  accessKey: process.env.MINIO_ACCESS_KEY,
  secretKey: process.env.MINIO_SECRET_KEY
})

// Buat buckets jika belum ada
async function initBuckets() {
  const buckets = [
    process.env.MINIO_BUCKET_PHOTOS,
    process.env.MINIO_BUCKET_VIDEOS,
    process.env.MINIO_BUCKET_REPORTS
  ]
  
  for (const bucket of buckets) {
    const exists = await minioClient.bucketExists(bucket)
    if (!exists) {
      await minioClient.makeBucket(bucket, 'us-east-1')
      console.log(`Bucket ${bucket} created`)
      
      // Set public policy untuk photos dan videos
      if (bucket !== process.env.MINIO_BUCKET_REPORTS) {
        const policy = {
          Version: '2012-10-17',
          Statement: [{
            Effect: 'Allow',
            Principal: { AWS: ['*'] },
            Action: ['s3:GetObject'],
            Resource: [`arn:aws:s3:::${bucket}/*`]
          }]
        }
        await minioClient.setBucketPolicy(bucket, JSON.stringify(policy))
      }
    }
  }
}

initBuckets().catch(console.error)

export default minioClient
```

**4. backend/src/models/Practicum.js**

```javascript
import mongoose from 'mongoose'

const fieldSchema = new mongoose.Schema({
  id: { type: String, required: true },
  label: { type: String, required: true },
  type: { 
    type: String, 
    enum: ['image', 'video', 'text', 'number', 'select', 'multiselect', 'checkbox'],
    required: true 
  },
  required: { type: Boolean, default: false },
  unit: String, // untuk type number
  options: [String], // untuk type select/multiselect
  min: Number, // untuk type number
  max: Number, // untuk type number
  aiAnalysis: { type: Boolean, default: false },
  aiPrompt: String,
  placeholder: String,
  helpText: String
})

const practicumSchema = new mongoose.Schema({
  code: { type: String, required: true, unique: true, index: true },
  codeHash: { type: String, required: true },
  title: { type: String, required: true },
  subject: { type: String, required: true },
  class: { type: String, required: true },
  teacherId: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
  date: { type: Date, required: true },
  duration: { type: Number, required: true }, // dalam menit
  fields: [fieldSchema],
  instructions: { type: String, required: true },
  minDataPoints: { type: Number, default: 1 },
  maxDataPoints: { type: Number, default: 10 },
  scoring: {
    completeness: { type: Number, default: 33 },
    quality: { type: Number, default: 33 },
    accuracy: { type: Number, default: 34 }
  },
  status: { 
    type: String, 
    enum: ['draft', 'active', 'completed', 'cancelled'],
    default: 'active'
  },
  createdAt: { type: Date, default: Date.now },
  updatedAt: { type: Date, default: Date.now }
}, { timestamps: true })

// Index untuk query performance
practicumSchema.index({ teacherId: 1, status: 1 })
practicumSchema.index({ date: -1 })

export default mongoose.model('Practicum', practicumSchema)
```

**5. backend/src/models/Submission.js**

```javascript
import mongoose from 'mongoose'

const dataPointSchema = new mongoose.Schema({
  number: { type: Number, required: true },
  data: { type: mongoose.Schema.Types.Mixed, required: true },
  aiAnalysis: { type: mongoose.Schema.Types.Mixed },
  aiStatus: { 
    type: String, 
    enum: ['pending', 'processing', 'completed', 'failed'],
    default: 'pending'
  },
  aiError: String,
  aiProcessedAt: Date,
  uploadedAt: { type: Date, default: Date.now },
  updatedAt: { type: Date, default: Date.now }
})

const submissionSchema = new mongoose.Schema({
  practicumId: { 
    type: mongoose.Schema.Types.ObjectId, 
    ref: 'Practicum', 
    required: true,
    index: true
  },
  studentId: { 
    type: mongoose.Schema.Types.ObjectId, 
    ref: 'User', 
    required: true,
    index: true
  },
  studentName: { type: String, required: true },
  studentClass: { type: String, required: true },
  studentNumber: String,
  status: { 
    type: String, 
    enum: ['in_progress', 'submitted', 'graded'],
    default: 'in_progress',
    index: true
  },
  data: [dataPointSchema],
  score: { type: Number, min: 0, max: 100 },
  scoreBreakdown: {
    completeness: Number,
    quality: Number,
    accuracy: Number
  },
  teacherFeedback: String,
  startedAt: { type: Date, default: Date.now },
  submittedAt: Date,
  gradedAt: Date,
  reportUrl: String
}, { timestamps: true })

// Compound index untuk unique submission per student per practicum
submissionSchema.index({ practicumId: 1, studentId: 1 }, { unique: true })

// Index untuk query performance
submissionSchema.index({ status: 1, submittedAt: -1 })

export default mongoose.model('Submission', submissionSchema)
```

**6. backend/src/services/geminiService.js**

```javascript
import axios from 'axios'

const GEMINI_API_URL = 'https://generativelanguage.googleapis.com/v1/models/gemini-1.5-flash:generateContent'

class GeminiService {
  constructor() {
    this.apiKey = process.env.GEMINI_API_KEY
  }
  
  async analyzeImage(imageBuffer, prompt, mimeType = 'image/jpeg') {
    try {
      const base64Image = imageBuffer.toString('base64')
      
      const response = await axios.post(
        `${GEMINI_API_URL}?key=${this.apiKey}`,
        {
          contents: [{
            parts: [
              { text: prompt },
              {
                inline_data: {
                  mime_type: mimeType,
                  data: base64Image
                }
              }
            ]
          }],
          generationConfig: {
            temperature: 0.4,
            topK: 32,
            topP: 1,
            maxOutputTokens: 2048
          },
          safetySettings: [
            {
              category: 'HARM_CATEGORY_HARASSMENT',
              threshold: 'BLOCK_MEDIUM_AND_ABOVE'
            }
          ]
        },
        {
          headers: {
            'Content-Type': 'application/json'
          },
          timeout: 30000
        }
      )
      
      const text = response.data.candidates[0].content.parts[0].text
      
      // Extract JSON jika ada
      const jsonMatch = text.match(/\{[\s\S]*\}/)
      if (jsonMatch) {
        return JSON.parse(jsonMatch[0])
      }
      
      return { text }
      
    } catch (error) {
      console.error('Gemini API error:', error.response?.data || error.message)
      throw new Error(`AI analysis failed: ${error.message}`)
    }
  }
  
  async analyzeVideo(videoBuffer, prompt) {
    // Video analysis butuh upload ke Google Cloud Storage dulu
    // Untuk MVP, bisa skip atau analisis frame pertama saja
    throw new Error('Video analysis not implemented yet')
  }
  
  generatePromptForField(fieldConfig, contextData = {}) {
    const basePrompts = {
      plant_identification: `
        Kamu adalah ahli botani. Analisis foto tumbuhan ini dan berikan:
        1. Nama ilmiah (scientific name) jika bisa diidentifikasi
        2. Nama umum dalam bahasa Indonesia
        3. Ciri-ciri khas yang terlihat (bentuk daun, tepi daun, pertulangan, dll)
        4. Klasifikasi: dikotil atau monokotil
        5. Tingkat kepercayaan identifikasi (0-100%)
        
        Format response dalam JSON:
        {
          "scientificName": "string",
          "commonName": "string",
          "characteristics": ["string"],
          "classification": "dikotil/monokotil",
          "confidence": number
        }
      `,
      chemical_reaction: `
        Kamu adalah ahli kimia. Analisis foto reaksi kimia ini dan berikan:
        1. Perubahan yang terlihat (warna, endapan, gas, dll)
        2. Kemungkinan reaksi yang terjadi
        3. Indikasi hasil reaksi (asam/basa/netral jika ada indikator)
        
        Format response dalam JSON:
        {
          "observedChanges": ["string"],
          "possibleReaction": "string",
          "indication": "string"
        }
      `,
      physics_measurement: `
        Analisis foto pengukuran fisika ini dan berikan:
        1. Pembacaan alat ukur yang terlihat
        2. Satuan yang digunakan
        3. Tingkat ketelitian pembacaan
        
        Format response dalam JSON:
        {
          "reading": "string",
          "unit": "string",
          "precision": "string"
        }
      `
    }
    
    return fieldConfig.aiPrompt || basePrompts.plant_identification
  }
}

export default new GeminiService()
```

**7. backend/src/services/minioService.js**

```javascript
import minioClient from '../config/minio.js'
import crypto from 'crypto'
import path from 'path'

class MinioService {
  async uploadFile(file, bucket, prefix = '') {
    try {
      // Generate unique filename
      const ext = path.extname(file.originalname)
      const hash = crypto.randomBytes(8).toString('hex')
      const timestamp = Date.now()
      const filename = `${prefix}${timestamp}_${hash}${ext}`
      
      // Upload ke MinIO
      await minioClient.putObject(
        bucket,
        filename,
        file.buffer,
        file.size,
        {
          'Content-Type': file.mimetype
        }
      )
      
      // Generate URL
      const url = `http://${process.env
      ```javascript
      // Generate URL
      const url = `http://${process.env.MINIO_ENDPOINT}:${process.env.MINIO_PORT}/${bucket}/${filename}`
      
      return {
        url,
        filename,
        bucket,
        size: file.size,
        mimetype: file.mimetype
      }
      
    } catch (error) {
      console.error('MinIO upload error:', error)
      throw new Error(`File upload failed: ${error.message}`)
    }
  }
  
  async downloadFile(bucket, filename) {
    try {
      const stream = await minioClient.getObject(bucket, filename)
      const chunks = []
      
      return new Promise((resolve, reject) => {
        stream.on('data', (chunk) => chunks.push(chunk))
        stream.on('end', () => resolve(Buffer.concat(chunks)))
        stream.on('error', reject)
      })
      
    } catch (error) {
      console.error('MinIO download error:', error)
      throw new Error(`File download failed: ${error.message}`)
    }
  }
  
  async deleteFile(bucket, filename) {
    try {
      await minioClient.removeObject(bucket, filename)
      return true
    } catch (error) {
      console.error('MinIO delete error:', error)
      throw new Error(`File deletion failed: ${error.message}`)
    }
  }
  
  async getFileUrl(bucket, filename, expirySeconds = 3600) {
    try {
      const url = await minioClient.presignedGetObject(bucket, filename, expirySeconds)
      return url
    } catch (error) {
      console.error('MinIO URL generation error:', error)
      throw new Error(`URL generation failed: ${error.message}`)
    }
  }
  
  async listFiles(bucket, prefix = '') {
    try {
      const stream = minioClient.listObjects(bucket, prefix, true)
      const files = []
      
      return new Promise((resolve, reject) => {
        stream.on('data', (obj) => files.push(obj))
        stream.on('end', () => resolve(files))
        stream.on('error', reject)
      })
      
    } catch (error) {
      console.error('MinIO list error:', error)
      throw new Error(`File listing failed: ${error.message}`)
    }
  }
}

export default new MinioService()
```

**8. backend/src/queues/aiAnalysisQueue.js**

```javascript
import { Queue, Worker } from 'bullmq'
import Redis from 'ioredis'
import Submission from '../models/Submission.js'
import geminiService from '../services/geminiService.js'
import minioService from '../services/minioService.js'

const connection = new Redis({
  host: process.env.REDIS_HOST,
  port: process.env.REDIS_PORT,
  maxRetriesPerRequest: null
})

// Buat queue
export const aiQueue = new Queue('ai-analysis', { 
  connection,
  defaultJobOptions: {
    attempts: 3,
    backoff: {
      type: 'exponential',
      delay: 2000
    },
    removeOnComplete: 100,
    removeOnFail: 50
  }
})

// Worker untuk proses AI
const worker = new Worker('ai-analysis', async (job) => {
  const { submissionId, dataPointNumber, fieldId, fileInfo, aiPrompt } = job.data
  
  console.log(`[AI Worker] Processing submission ${submissionId}, data point ${dataPointNumber}, field ${fieldId}`)
  
  try {
    // Update status ke processing
    await Submission.updateOne(
      { 
        _id: submissionId,
        'data.number': dataPointNumber
      },
      {
        $set: {
          'data.$.aiStatus': 'processing'
        }
      }
    )
    
    // Download file dari MinIO
    console.log(`[AI Worker] Downloading file from MinIO: ${fileInfo.bucket}/${fileInfo.filename}`)
    const fileBuffer = await minioService.downloadFile(fileInfo.bucket, fileInfo.filename)
    
    // Panggil Gemini API
    console.log(`[AI Worker] Calling Gemini API...`)
    const aiResult = await geminiService.analyzeImage(fileBuffer, aiPrompt, fileInfo.mimetype)
    
    console.log(`[AI Worker] AI analysis result:`, aiResult)
    
    // Simpan hasil ke MongoDB
    await Submission.updateOne(
      { 
        _id: submissionId,
        'data.number': dataPointNumber
      },
      {
        $set: {
          [`data.$.data.${fieldId}_analysis`]: aiResult,
          'data.$.aiStatus': 'completed',
          'data.$.aiProcessedAt': new Date()
        }
      }
    )
    
    // Emit event ke Socket.io (akan dihandle di controller)
    const submission = await Submission.findById(submissionId).populate('practicumId')
    
    // Return data untuk emit via socket
    return {
      submissionId,
      dataPointNumber,
      fieldId,
      aiResult,
      studentName: submission.studentName,
      practicumId: submission.practicumId._id
    }
    
  } catch (error) {
    console.error(`[AI Worker] Error:`, error)
    
    // Update status ke failed
    await Submission.updateOne(
      { 
        _id: submissionId,
        'data.number': dataPointNumber
      },
      {
        $set: {
          'data.$.aiStatus': 'failed',
          'data.$.aiError': error.message
        }
      }
    )
    
    throw error
  }
}, { 
  connection,
  concurrency: 5 // Proses 5 job sekaligus
})

worker.on('completed', (job, result) => {
  console.log(`[AI Worker] Job ${job.id} completed`)
  
  // Emit ke Socket.io
  if (global.io && result) {
    global.io.to(`practicum_${result.practicumId}`).emit('ai-analysis-complete', {
      submissionId: result.submissionId,
      dataPointNumber: result.dataPointNumber,
      fieldId: result.fieldId,
      studentName: result.studentName,
      analysis: result.aiResult
    })
  }
})

worker.on('failed', (job, err) => {
  console.error(`[AI Worker] Job ${job.id} failed:`, err.message)
})

worker.on('error', (err) => {
  console.error('[AI Worker] Worker error:', err)
})

console.log('[AI Worker] Worker started')

export default worker
```

**9. backend/src/controllers/submissionController.js**

```javascript
import Submission from '../models/Submission.js'
import Practicum from '../models/Practicum.js'
import minioService from '../services/minioService.js'
import { aiQueue } from '../queues/aiAnalysisQueue.js'
import sharp from 'sharp'

class SubmissionController {
  
  // Upload data point
  async uploadData(req, res) {
    try {
      const { submissionId, dataPointNumber } = req.body
      const files = req.files
      
      // Validasi submission
      const submission = await Submission.findById(submissionId).populate('practicumId')
      if (!submission) {
        return res.status(404).json({ success: false, message: 'Submission not found' })
      }
      
      // Cek apakah siswa yang login sesuai dengan submission
      if (submission.studentId.toString() !== req.user.id) {
        return res.status(403).json({ success: false, message: 'Unauthorized' })
      }
      
      // Cek apakah sudah di-submit
      if (submission.status !== 'in_progress') {
        return res.status(400).json({ success: false, message: 'Submission already submitted' })
      }
      
      const practicum = submission.practicumId
      const dataPoint = {
        number: parseInt(dataPointNumber),
        data: {},
        aiStatus: 'pending',
        uploadedAt: new Date()
      }
      
      // Process setiap field
      for (const field of practicum.fields) {
        const fieldValue = req.body[field.id]
        const fieldFile = files?.[field.id]?.[0]
        
        if (field.type === 'image' || field.type === 'video') {
          if (!fieldFile) {
            if (field.required) {
              return res.status(400).json({ 
                success: false, 
                message: `Field ${field.label} is required` 
              })
            }
            continue
          }
          
          // Kompresi image jika terlalu besar
          let fileBuffer = fieldFile.buffer
          if (field.type === 'image' && fieldFile.size > 1 * 1024 * 1024) {
            console.log(`Compressing image ${fieldFile.originalname}`)
            fileBuffer = await sharp(fieldFile.buffer)
              .resize(1920, 1920, { fit: 'inside', withoutEnlargement: true })
              .jpeg({ quality: 85 })
              .toBuffer()
          }
          
          // Upload ke MinIO
          const bucket = field.type === 'image' 
            ? process.env.MINIO_BUCKET_PHOTOS 
            : process.env.MINIO_BUCKET_VIDEOS
          
          const prefix = `${submissionId}/data${dataPointNumber}/`
          
          const uploadResult = await minioService.uploadFile(
            { ...fieldFile, buffer: fileBuffer, size: fileBuffer.length },
            bucket,
            prefix
          )
          
          dataPoint.data[field.id] = uploadResult
          
          // Tambahkan job AI jika field butuh analisis
          if (field.aiAnalysis) {
            const aiPrompt = geminiService.generatePromptForField(field)
            
            await aiQueue.add('analyze', {
              submissionId: submission._id.toString(),
              dataPointNumber: parseInt(dataPointNumber),
              fieldId: field.id,
              fileInfo: {
                bucket: uploadResult.bucket,
                filename: uploadResult.filename,
                mimetype: uploadResult.mimetype
              },
              aiPrompt
            })
            
            console.log(`AI job added for submission ${submissionId}, field ${field.id}`)
          }
          
        } else {
          // Text, number, select, dll
          if (!fieldValue && field.required) {
            return res.status(400).json({ 
              success: false, 
              message: `Field ${field.label} is required` 
            })
          }
          
          // Validasi tipe data
          if (field.type === 'number') {
            const numValue = parseFloat(fieldValue)
            if (isNaN(numValue)) {
              return res.status(400).json({ 
                success: false, 
                message: `Field ${field.label} must be a number` 
              })
            }
            if (field.min !== undefined && numValue < field.min) {
              return res.status(400).json({ 
                success: false, 
                message: `Field ${field.label} must be at least ${field.min}` 
              })
            }
            if (field.max !== undefined && numValue > field.max) {
              return res.status(400).json({ 
                success: false, 
                message: `Field ${field.label} must be at most ${field.max}` 
              })
            }
            dataPoint.data[field.id] = numValue
          } else {
            dataPoint.data[field.id] = fieldValue
          }
        }
      }
      
      // Cek apakah data point number sudah ada
      const existingIndex = submission.data.findIndex(d => d.number === dataPoint.number)
      
      if (existingIndex >= 0) {
        // Update existing
        submission.data[existingIndex] = dataPoint
      } else {
        // Cek max data points
        if (submission.data.length >= practicum.maxDataPoints) {
          return res.status(400).json({ 
            success: false, 
            message: `Maximum ${practicum.maxDataPoints} data points allowed` 
          })
        }
        // Add new
        submission.data.push(dataPoint)
      }
      
      await submission.save()
      
      // Emit real-time event
      const io = req.app.get('io')
      io.to(`practicum_${practicum._id}`).emit('data-uploaded', {
        submissionId: submission._id,
        studentName: submission.studentName,
        dataPointNumber: dataPoint.number,
        timestamp: new Date()
      })
      
      res.json({
        success: true,
        dataPoint,
        message: 'Data uploaded successfully'
      })
      
    } catch (error) {
      console.error('Upload data error:', error)
      res.status(500).json({ 
        success: false, 
        message: 'Failed to upload data',
        error: error.message 
      })
    }
  }
  
  // Get submission detail
  async getSubmission(req, res) {
    try {
      const { id } = req.params
      
      const submission = await Submission.findById(id)
        .populate('practicumId')
        .populate('studentId', 'name email')
      
      if (!submission) {
        return res.status(404).json({ success: false, message: 'Submission not found' })
      }
      
      // Cek authorization
      const isStudent = submission.studentId._id.toString() === req.user.id
      const isTeacher = req.user.role === 'teacher' && 
                       submission.practicumId.teacherId.toString() === req.user.id
      
      if (!isStudent && !isTeacher) {
        return res.status(403).json({ success: false, message: 'Unauthorized' })
      }
      
      res.json({ success: true, submission })
      
    } catch (error) {
      console.error('Get submission error:', error)
      res.status(500).json({ 
        success: false, 
        message: 'Failed to get submission',
        error: error.message 
      })
    }
  }
  
  // Submit (finalize) submission
  async submitSubmission(req, res) {
    try {
      const { id } = req.params
      
      const submission = await Submission.findById(id).populate('practicumId')
      if (!submission) {
        return res.status(404).json({ success: false, message: 'Submission not found' })
      }
      
      // Cek authorization
      if (submission.studentId.toString() !== req.user.id) {
        return res.status(403).json({ success: false, message: 'Unauthorized' })
      }
      
      if (submission.status !== 'in_progress') {
        return res.status(400).json({ success: false, message: 'Submission already submitted' })
      }
      
      // Validasi min data points
      if (submission.data.length < submission.practicumId.minDataPoints) {
        return res.status(400).json({ 
          success: false, 
          message: `Minimum ${submission.practicumId.minDataPoints} data points required` 
        })
      }
      
      submission.status = 'submitted'
      submission.submittedAt = new Date()
      await submission.save()
      
      // Emit real-time event
      const io = req.app.get('io')
      io.to(`practicum_${submission.practicumId._id}`).emit('submission-submitted', {
        submissionId: submission._id,
        studentName: submission.studentName,
        timestamp: new Date()
      })
      
      res.json({
        success: true,
        submission,
        message: 'Submission submitted successfully'
      })
      
    } catch (error) {
      console.error('Submit submission error:', error)
      res.status(500).json({ 
        success: false, 
        message: 'Failed to submit submission',
        error: error.message 
      })
    }
  }
  
  // Grade submission (guru)
  async gradeSubmission(req, res) {
    try {
      const { id } = req.params
      const { score, feedback, breakdown } = req.body
      
      const submission = await Submission.findById(id).populate('practicumId')
      if (!submission) {
        return res.status(404).json({ success: false, message: 'Submission not found' })
      }
      
      // Cek authorization (harus guru yang buat practicum)
      if (submission.practicumId.teacherId.toString() !== req.user.id) {
        return res.status(403).json({ success: false, message: 'Unauthorized' })
      }
      
      if (submission.status === 'in_progress') {
        return res.status(400).json({ success: false, message: 'Submission not submitted yet' })
      }
      
      // Validasi score
      if (score < 0 || score > 100) {
        return res.status(400).json({ success: false, message: 'Score must be between 0-100' })
      }
      
      submission.score = score
      submission.teacherFeedback = feedback
      submission.scoreBreakdown = breakdown
      submission.status = 'graded'
      submission.gradedAt = new Date()
      await submission.save()
      
      // Emit real-time event ke siswa
      const io = req.app.get('io')
      io.to(`student_${submission.studentId}`).emit('submission-graded', {
        submissionId: submission._id,
        practicumTitle: submission.practicumId.title,
        score,
        timestamp: new Date()
      })
      
      res.json({
        success: true,
        submission,
        message: 'Submission graded successfully'
      })
      
    } catch (error) {
      console.error('Grade submission error:', error)
      res.status(500).json({ 
        success: false, 
        message: 'Failed to grade submission',
        error: error.message 
      })
    }
  }
  
  // Delete data point
  async deleteDataPoint(req, res) {
    try {
      const { id, dataNumber } = req.params
      
      const submission = await Submission.findById(id)
      if (!submission) {
        return res.status(404).json({ success: false, message: 'Submission not found' })
      }
      
      // Cek authorization
      const isStudent = submission.studentId.toString() === req.user.id
      const isTeacher = req.user.role === 'teacher'
      
      if (!isStudent && !isTeacher) {
        return res.status(403).json({ success: false, message: 'Unauthorized' })
      }
      
      if (submission.status !== 'in_progress') {
        return res.status(400).json({ success: false, message: 'Cannot delete from submitted submission' })
      }
      
      // Find data point
      const dataIndex = submission.data.findIndex(d => d.number === parseInt(dataNumber))
      if (dataIndex < 0) {
        return res.status(404).json({ success: false, message: 'Data point not found' })
      }
      
      // Delete files dari MinIO
      const dataPoint = submission.data[dataIndex]
      for (const [key, value] of Object.entries(dataPoint.data)) {
        if (value && typeof value === 'object' && value.bucket && value.filename) {
          try {
            await minioService.deleteFile(value.bucket, value.filename)
          } catch (err) {
            console.error(`Failed to delete file ${value.filename}:`, err)
          }
        }
      }
      
      // Remove dari array
      submission.data.splice(dataIndex, 1)
      await submission.save()
      
      res.json({
        success: true,
        message: 'Data point deleted successfully'
      })
      
    } catch (error) {
      console.error('Delete data point error:', error)
      res.status(500).json({ 
        success: false, 
        message: 'Failed to delete data point',
        error: error.message 
      })
    }
  }
}

export default new SubmissionController()
```

**10. backend/src/services/pdfService.js**

```javascript
import puppeteer from 'puppeteer'
import minioService from './minioService.js'

class PDFService {
  
  async generateReport(submission, practicum) {
    try {
      console.log(`Generating PDF report for submission ${submission._id}`)
      
      const browser = await puppeteer.launch({
        headless: 'new',
        args: [
          '--no-sandbox',
          '--disable-setuid-sandbox',
          '--disable-dev-shm-usage'
        ]
      })
      
      const page = await browser.newPage()
      
      // Buat HTML template
      const html = this.generateHTMLTemplate(submission, practicum)
      
      await page.setContent(html, { 
        waitUntil: 'networkidle0',
        timeout: 30000
      })
      
      // Generate PDF
      const pdfBuffer = await page.pdf({
        format: 'A4',
        printBackground: true,
        margin: {
          top: '20mm',
          right: '15mm',
          bottom: '20mm',
          left: '15mm'
        }
      })
      
      await browser.close()
      
      // Upload ke MinIO
      const filename = `laporan_${submission.studentName.replace(/\s/g, '_')}_${submission._id}.pdf`
      const uploadResult = await minioService.uploadFile(
        {
          buffer: pdfBuffer,
          originalname: filename,
          mimetype: 'application/pdf',
          size: pdfBuffer.length
        },
        process.env.MINIO_BUCKET_REPORTS,
        `${practicum._id}/`
      )
      
      console.log(`PDF generated: ${uploadResult.url}`)
      
      return uploadResult
      
    } catch (error) {
      console.error('PDF generation error:', error)
      throw new Error(`Failed to generate PDF: ${error.message}`)
    }
  }
  
  generateHTMLTemplate(submission, practicum) {
    const formatDate = (date) => {
      return new Date(date).toLocaleDateString('id-ID', {
        day: 'numeric',
        month: 'long',
        year: 'numeric'
      })
    }
    
    return `
      <!DOCTYPE html>
      <html lang="id">
      <head>
        <meta charset="UTF-8">
        <style>
          * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
          }
          body {
            font-family: 'Arial', sans-serif;
            line-height: 1.6;
            color: #333;
            padding: 20px;
          }
          .header {
            text-align: center;
            border-bottom: 3px solid #2563eb;
            padding-bottom: 20px;
            margin-bottom: 30px;
          }
          .header h1 {
            color: #1e40af;
            font-size: 24px;
            margin-bottom: 5px;
          }
          .header h2 {
            color: #64748b;
            font-size: 18px;
            font-weight: normal;
            margin-bottom: 15px;
          }
          .info-box {
            background: #f1f5f9;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
          }
          .info-row {
            display: flex;
            margin-bottom: 8px;
          }
          .info-label {
            font-weight: bold;
            width: 150px;
            color: #475569;
          }
          .info-value {
            flex: 1;
            color: #0f172a;
          }
          .section {
            margin-bottom: 30px;
            page-break-inside: avoid;
          }
          .section-title {
            background: #2563eb;
            color: white;
            padding: 10px 15px;
            border-radius: 6px;
            font-size: 16px;
            margin-bottom: 15px;
          }
          .data-point {
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            page-break-inside: avoid;
          }
          .data-point h3 {
            color: #1e40af;
            font-size: 14px;
            margin-bottom: 12px;
            border-bottom: 2px solid #dbeafe;
            padding-bottom: 5px;
          }
          .field-group {
            margin-bottom: 12px;
          }
          .field-label {
            font-weight: bold;
            color: #475569;
            font-size: 13px;
            margin-bottom: 5px;
          }
          .field-value {
            color: #0f172a;
            font-size: 13px;
          }
          .image-container {
            margin: 10px 0;
            text-align: center;
          }
          .image-container img {
            max-width: 400px;
            max-height: 300px;
            border: 1px solid #cbd5e1;
            border-radius: 6px;
          }
          .ai-analysis {
            background: #f0f9ff;
            border-left: 4px solid #0ea5e9;
            padding: 12px;
            margin-top: 10px;
            border-radius: 4px;
          }
          .ai-analysis h4 {
            color: #0369a1;
            font-size: 13px;
            margin-bottom: 8px;
          }
          .ai-analysis p {
            font-size: 12px;
            margin-bottom: 5px;
          }
          .grading-section {
            background: #fefce8;
            border: 2px solid #fbbf24;
            border-radius: 8px;
            padding: 20px;
            margin-top: 30px;
          }
          .grading-section h3 {
            color: #92400e;
            font-size: 16px;
            margin-bottom: 15px;
          }
          .score-box {
            background: white;
            border: 2px solid #10b981;
            border-radius: 8px;
            padding: 15px;
            text-align: center;
            margin-bottom: 15px;
          }
          .score-box .score {
            font-size: 36px;
            font-weight: bold;
            color: #059669;
          }
          .score-breakdown {
            display: flex;
            justify-content: space-around;
            margin-bottom: 15px;
          }
          .score-item {
            text-align: center;
          }
          .score-item .label {
            font-size: 12px;
            color: #64748b;
          }
          .score-item .value {
            font-size: 18px;
            font-weight: bold;
            color: #0f172a;
          }
          .feedback {
            background: white;
            padding: 12px;
            border-radius: 6px;
            font-size: 13px;
            line-height: 1.8;
          }
          .footer {
            margin-top: 40px;
            text-align: center;
            font-size: 11px;
            color: #94a3b8;
            border-top: 1px solid #e2e8f0;
            padding-top: 15px;
          }
        </style>
      </head>
      <body>
        <div class="header">
          <h1>LAPORAN PRAKTIKUM</h1>
          <h2>${practicum.title}</h2>
        </div>
        
        <div class="info-box">
          <div class="info-row">
            <div class="info-label">Nama Siswa</div>
            <div class="info-value">${submission.studentName}</div>
          </div>
          <div class="info-row">
            <div class="info-label">Kelas</div>
            <div class="info-value">${submission.studentClass}</div>
          </div>
          <div class="info-row">
            <div class="info-label">Mata Pelajaran</div>
            <div class="info-value">${practicum.subject}</div>
          </div>
          <div class="info-row">
            <div class="info-label">Tanggal Praktikum</div>
            <div class="info-value">${formatDate(practicum.date)}</div>
          </div>
          <div class="info-row">
            <div class="info-label">Tanggal Pengumpulan</div>
            <div class="info-value">${formatDate(submission.submittedAt)}</div>
          </div>
        </div>
        
        <div class="section">
          <div class="section-title">Tujuan Praktikum</div>
          <p style="padding: 0 15px; text-align: justify;">${practicum.instructions}</p>
        </div>
        
        <div class="section">
          <div class="section-title">Data Observasi</div>
          
          ${submission.data.map((dataPoint, index) => `
            <div class="data-point">
              <h3>Data ${dataPoint.number}</h3>
              
              ${Object.entries(dataPoint.data).map(([fieldId, value]) => {
                const field = practicum.fields.find(f => f.id === fieldId)
                if (!field) return ''
                
                if (field.type === 'image' && value.url) {
                  const analysis = dataPoint.data[`${fieldId}_analysis`]
                  return `
                    <div class="field-group">
                      <div class="field-label">${field.label}</div>
                      <div class="image-container">
                        <img src="${value.url}" alt="${field.label}" />
                      </div>
                      ${analysis ? `
                        <div class="ai-analysis">
                          <h4>ğŸ¤– Hasil Analisis AI</h4>
                          ${analysis.scientificName ? `<p><strong>Nama Ilmiah:</strong> <em>${analysis.scientificName}</em></p>` : ''}
                          ${analysis.commonName ? `<p><strong>Nama Umum:</strong> ${analysis.commonName}</p>` : ''}
                          ${analysis.classification ? `<p><strong>Klasifikasi:</strong> ${analysis.classification}</p>` : ''}
                          ${analysis.confidence ? `<p><strong>Confidence:</strong> ${analysis.confidence}%</p>` : ''}
                          ${analysis.characteristics ? `<p><strong>Ciri-ciri:</strong> ${analysis.characteristics.join(', ')}</p>` : ''}
                        </div>
                      ` : ''}
                    </div>
                  `
                } else if (typeof value === 'object') {
                  return ''
                } else {
                  return `